## Abstract

二进制代码分析是许多应用程序的支持技术。现代编译器和运行时库为二进制代码引入了重要的复杂性，这会对二进制分析工具包分析二进制代码的能力产生负面影响，并可能导致工具报告有关二进制代码的不准确信息。因此，分析师可能会感到困惑，基于这些工具包的应用程序可能会降低质量。我们研究了从二进制代码构造控制流图并用精确的函数边界注释标记图的问题。我们确定了几个具有挑战性的代码构造，它们代表了难以分析二进制代码的各个方面，并展示了每个代码构造的代码示例。作为讨论的一部分，我们在支持这些结构的开源Dyninst工具包中提供了新的代码解析算法，包括用于描述跳转表的新模型，该模型提高了我们精确确定控制目标的能力，新的过程间分析确定当函数不返回时，以及处理尾调用的技术。我们评估了各种工具包在使用真实软件处理这些代码构造时的效果，以及在真实软件中找到的每个具有挑战性的代码构造之后构建的测试二进制文件。

## Introduction

二进制代码分析用于广泛的应用，包括性能分析[1,15,33]，软件逆向工程[12,18]，调试[2]，软件可靠性[31]，软件取证[42]和安全性 [19,23,36]。 二进制代码的分析是这些应用程序中的关键功能，因为它不需要源代码可用，并且针对执行的实际软件工件。 即使你有源代码，经验表明执行的二进制代码的语义可能与源代码不同。

二进制代码分析可以是静态的或动态的。 在本文中，我们关注静态分析，因为它是许多领域的基础技术，包括动态分析（例如分析自修改代码和打包的恶意软件[9,38,44,51]）。 它的优点是它不需要执行程序，并且其分析覆盖范围不依赖于可用输入集的覆盖范围。

以前关于静态二进制代码分析的研究主要集中在识别和解决二进制代码中具有挑战性的代码构造，包括识别函数入口点[5,21,43]，解决间接控制问题[6,13,16,26,40,47] ，并消除非代码字节的歧义[46]。 本文的目标是改进这三种结构的处理，并扩展我们的研究，以包括其他具有挑战性的代码结构，以探索现代编译器和运行时库引入二进制代码的复杂性。

这些代码的复杂性影响分析师理解程序的操作和意图的能力，以及工具正确地检测或转换二进制程序以跟踪，调试，测试，监视或沙箱化的能力。 在我们自己的开源Dyninst工具包中支持这些代码构造[37]带来了普遍的好处，因为Dyninst被广泛用于构建调试工具，包括STAT [2]和SystemTap [17]，性能工具包括COBI [34]，Extrae [30]，HPCToolKit [1]和OpenjSpeedShop [45]，以及许多其他安全分析工具[19,23,39,44,50,53]和逆向工程[10,24,27,41,43]。

二进制代码分析工具包[3,11,22,37,47]提供了多种功能，可帮助用户自动执行二进制代码分析过程。 这些功能包括将字节解码为机器指令，理解指令语义，执行控制和数据流分析，以及将源语言语义分配给二进制代码。 这些功能中的每一个都可以构建在以前的功能上并与之交互; 最后一个，将源代码语义分配给二进制代码是微妙的，因为可以有多个合理且一致的赋值。

将字节解码为机器指令是二进制代码分析的第一步。当您知道指令的起始地址时，此功能很简单。但是，在许多情况下，指令的起始地址并不明显。在可执行文件（\ stripped“代码）中几乎没有符号的情况下，找到函数的起始地址可能很困难。缺少符号在常规代码的恶意代码和生产版本中都很常见。即使您可以找到函数的开头，函数内的间接控制流也可能使得所有代码变得困难。实际上，代码分析工具包很难解决这个问题，并且经常会错过实际指令或报告虚假指令。常见问题包括报告编译器作为实际指令插入的填充字节，缺少共享字节的指令（令人惊讶的是，不仅在恶意软件中而且在传统代码中发生），将数据字节解释为代码，以及将代码误解为数据字节。

从二进制代码构建控制流图（CFG）描述了程序的基本结构。 它还为数据流分析和强大的二进制仪器和修改奠定了基础[7,8]。 但是，工具包通常会产生不准确的CFG，无法识别非返回功能并且不精确地处理间接控制流。

将源语言语义分配给二进制代码是一个更有趣的问题，它使用熟悉的结构（如函数，循环，函数参数和局部变量）表示二进制分析结果。 这样的功能对于程序员理解程序所熟悉的程度是必要的，在程序员具有源代码时提供合理的标记，并为程序仪表和修改提供具体的目标。 但是，工具包通常很难识别这些结构。 常见问题包括不了解函数不再在内存中连续分配，函数可以交错，函数可以共享代码。 这些过度使用可能导致二进制代码和源代码之间的不准确对应。

当分析工具包提供不准确的信息时，基于二进制代码分析构建的工具会受到影响。 如果提供的性能分析工具在二进制代码和源代码之间存在不准确的对应关系，则可能会将原始数据归因于源代码中的错误位置，从而导致用户错过识别性能瓶颈[1]。 安全应用程序需要有关二进制文件的准确信息，以避免错过攻击或报告错误警报[23,52]。 此外，如果CFG不准确，数据流分析可能不精确。 二进制检测[8,32]经常使用寄存器活性分析来确定仪器可以使用哪些寄存器而不会引入溢出; 准确的数据流分析在这里至关重要。 在二进制分析工具包之上构建的工具几乎总是假设底层工具包提供准确的信息，如果信息不准确则可能会出错。

在本文中，我们研究了从二进制代码构造CFG并用准确的函数边界注释标记CFG的问题。 解决此问题需要查找指令，构建CFG和分配源函数语义的交互功能。 我们将问题分为三个分析阶段：

* 代码挖掘，找到二进制中的所有指令;
* CFG构建，确定基本块并连接它们之间的边缘（并知道何时不连接边缘）
* CFG分区，将边缘标记为程序间或程序内以确定功能边界

根据我们构建二进制分析工具包的经验，我们已经确定了在实际代码中找到的八个具有挑战性的代码结构，这些结构常常会混淆工具。 对于这些构造，我们使用代码示例来讨论它们的难度，并提出我们处理它们的策略。 特别是，我们提出了一个描述跳转表的新模型，它提高了我们精确确定控制流目标的能力，用于确定函数是否返回的新的过程间分析，以及处理尾调用，重叠函数和重叠指令序列的技术。

我们使用了SPECint 2006并创建了在每个具有挑战性的代码构造之后进行模式化的测试二进制文件，以评估几种常用的二元分析工具包，包括BAP [11]，GNU Objdump [20]，IDA Pro [22]，Jakstab [25]， OllyDbg [35]，SecondWrite [47]和Dyninst [37]。 我们的结果表明，这些具有挑战性的代码构造在真实软件中很普遍，并且大多数这些工具包可能会被具有挑战性的代码构造所混淆，因此在这些情况下可能会提供有关二进制文件的不准确信息。 这项研究的基本信息是，虽然为公共代码构造构建二进制分析工具包是一项众所周知的任务，但处理现代编译器生成的全部代码会增加大量工作。

我们在第2节中介绍了基本定义作为背景。在第3节中，我们概述了我们的8个具有挑战性的代码结构，并从第4节到第6节详细讨论它们。我们在第7节中对现有的二进制分析工具包进行了比较，并在结论中进行了总结。 第8节。

## Basic Definitions

构建和标记CFG的问题可以说是：给定一个程序，我们提取CFG和一组函数。 先前关于该问题的努力已经对程序，CFG和函数[4,5,13,26,40,48]的定义做出了各种简化假设。 常见的假设包括程序包含重定位信息[46]，函数调用总是返回[29]，函数体是独立的并且在内存中连续布局[5,26]。 然而，简化的定义并不总是适用于真实世界的二进制文件，并且不足以代表现实世界二进制文件的复杂性。 我们介绍了Bernat和Miller的程序，CFG和函数的定义[8]。 这些定义不会对二进制文件施加不必要的假设; 因此它们适合于代表我们在本文中讨论的具有挑战性的代码结构。

**Definition 1** 程序P定义为元组P =（C; D），其中C = <i0;I1; ::: ;; im>是P可以执行的指令序列，D表示数据。

Bernat和Miller指出，这个定义足以允许呈现真实世界的二进制文件：它不假设存在符号，调试或重定位信息; C和D可以在存储器中交错; C中的指令可以重叠。

**Definition 2** （CFG）

基本块B以常规方式定义。 每个基本块b = <i0;I1; ::: ;; in>是一个连续的指令序列，其中i0是唯一的条目，并且是唯一的退出。 汇聚节点v？ 用于表示未知控制流[8,11,26,48]，主要由间接跳转和间接调用引起。

**Definition 3 （Functions）** 

在这个函数定义下，函数可以共享代码，交错，并且在内存中是非连续的。 我们还可以将具有多个入口点的函数表示为共享代码的多个单入口点函数。 以前的一些项目已将函数定义为地址间隔[22,26,35]。 他们的定义无法正确地模拟这些具有挑战性的代码结构。

虽然上述定义适用于任何ISA，但在本文中，我们将重点放在x86和x86-64上，因为它们是常用的平台。 它们的指令具有可变长度，使得区分数据和代码以及识别填充字节更具挑战性。 我们关注剥离的二进制文件，以及之前的几个项目[4,5,21,43]。 解析剥离的二进制文件比使用符号和调试信息解析二进制文件更具挑战性。 但是，我们需要能够处理剥离的二进制文件，因为二进制代码经常在现实世界中被剥离。 能够处理剥离的二进制文件也为分析恶意代码提供了基础。

## Code Constructs Overview

根据我们构建二进制分析工具包的经验，我们确定了八个具有挑战性的代码构造。这些代码构造经常混淆现有的二进制分析工具包。工具包可能会错过实际指令，报告虚假控制流程或不准确标记功能边界。二进制分析中的上述不准确性对于识别至关重要，因为它们可能会阻止分析人员理解程序的结构和意图，并导致二进制检测和修改不安全，不正确或不完整。在本节中，我们概述了具有挑战性的代码结构，如表1所示。代码结构分为以下三个分析阶段：代码发现，查找程序可执行的C中的所有指令（第4节） ; CFG建筑，建筑节点和边缘G（第5节）;和CFG分区，确定CFG的哪些部分属于哪些功能（第6节）。在本节的最后，我们讨论了三个分析阶段之间的关系。

### Code Discovery

我们确定了三个代码构造，使代码发现变得困难。 如果三个结构处理不当，二进制分析工具包可能会将关键数据字节误解为指令或错过实际指令。 然后，二进制检测和修改可以修改关键数据字节并导致程序崩溃。 仪表和修改也可能是不完整的，因为错过了实际指令，这在安全应用程序中是不可容忍的。 三个具有挑战性的代码构造是：

*None-code bytes* 必须将代码与出现在代码段中的非代码字节区分开来，例如跳转表，只读数据和填充字节。 编译器可以在指令之间插入填充字节以对齐指令并提高缓存效率。 将这些非代码字节与实际代码区分开来并非易事，因为非代码字节通常可以被解码为有效指令。 请注意，即使编译器可能将只读数据和跳转表放入单独的只读数据段中，也不需要这样做。 实际上，我们发现Windows系统库通常不包含只读数据部分; 只读数据和跳转表嵌入在代码段中。

*Missing symbols* 程序的符号表不完整，缺失或不准确。 二进制分析工具包通常使用功能符号来识别功能入口点。 没有完整和准确的符号，这项任务就变得非常困难

*Overlapping instructions* 多条指令共享字节。 此代码构造仅存在于指令具有可变长度且指令的起始地址不需要对齐的体系结构上，例如x86和x86-64。 如果二进制分析工具包假设指令永远不会共享字节，它们将错过实际指令

### CFG Constructions

我们为CFG构建确定了两个具有挑战性的代码构造。 不恰当地处理它们可能会导致二进制分析工具包错过实际控制流程并报告虚假控制流程。 CFG中的不准确性会使分析人员感到困惑，并降低基于二进制分析的工具质量。 例如，如果函数包含未解析的过程间接控制流[8]，则结构化二进制编辑标记功能无法修改。 这两个代码结构是：

*Indirect control flow* 此代码构造引用间接跳转指令和间接调用指令。 间接控制流主要用于实现基于指针的控制流，虚函数和switch语句。 控制流目标是动态计算的，很难准确地确定它们。 在本文中，我们关注跳转表，跳转表是一组间接控制流，其中控制流目标的计算基于良好理解的结构。 跳转表通常表示过程内控制流，因此必须精确地解决它们以进行代码发现和应用程序（如结构化二进制编辑）

*None-returning functions* 对非返回函数的函数调用永远不会返回到此调用站点。 通常编译器知道调用是否会返回，因此在非返回调用之后，将立即安全地从相同的函数或代码中放入来自另一个函数的无关代码。 如果二进制分析工具包无法识别非返回函数，则会错误地报告控制流从非返回调用继续到下一个块。

### CFG Partitioning 

我们在CFG分区中识别了三个代码构造。 无法处理它们可能导致二进制分析工具包不准确地标记功能边界，这可能导致二进制仪器和修改中的问题。 两种常见的仪表操作是检测给定功能的所有基本块的条目并检测功能输入和退出。 如果功能边界不准确，我们可能会在错误的位置进行检测，或者错过我们应该检测的程序位置。 三个代码构造是：

*Functions Sharing Code* 函数可以共享代码块。 函数可能具有共同的功能，这导致共享相同的代码块，如错误处理代码和堆栈拆除代码。 共享代码也可能来自具有多个入口点的函数。 具有多个入口点的函数的两种可能表示是具有多个入口点的一个函数或者共享代码的多个单入口点函数。 据我们所知，没有工具使用第一个表示。 在第二种表示下，一个常见的错误是假设一段代码只能属于一个函数。 我们在libc中观察到了这个代码构造，代码由英特尔编译器（ICC）和Fortran函数编译，程序员指定了多个入口点（使用\ entry“关键字”）。

*None-contiguous functions* 函数的基本块在内存中不连续。 源代码中的函数在源文件中始终是连续的，但由于各种原因，此属性在二进制代码中可能不成立，包括编译器概述不经常执行的代码以提高缓存性能。 因此，我们不能简单地用从最低地址到最高地址的间隔来表示功能边界

*Tail call* 尾调用[14]是一种编译器优化，它使用函数末尾的跳转指令来定位另一个函数的入口点。 优化通过用跳转指令替换调用指令来消除堆栈帧设置和堆栈帧拆除。 如果二进制分析工具包无法识别尾调用，则从尾调用跳转指令到跳转目标的控制流边缘将被错误地标记为过程内。

### Relations between these three stages

我们对三个分析阶段之间的关系进行了两次观察。 首先，代码发现和CFG构造之间存在交互。 一方面，代码发现是构建CFG的基础，因为节点由指令块组成，控制流边缘由指令指定。 另一方面，控制流可用于解决代码发现中的挑战：
控制流指令的目标应始终是实数代码，而不是数据或填充字节; 可以通过遵循其输入控制流来识别重叠指令

其次，CFG分区基于代码发现和CFG构造。 CFG分区的一个重要任务是确定函数入口和出口。 当功能符号缺失，不完整或不准确时，确定函数条目显然更加困难。 对于函数出口，二进制函数通常终止于返回指令。 然而，这并非总是如此。 如上所述，尾调用（跳转指令）和对非返回函数的调用指令也终止函数。

虽然这是一个有问题的代码结构的有趣列表，但它绝不是完整的。 随着新代码生成器的产生，以及新的优化库的产生，将会有新的挑战性构造。

## Code Discovery

与实际指令，缺失符号和重叠指令混合的非代码字节都使代码发现变得复杂。 我们使用真实的代码示例来说明为什么这些代码构造具有挑战性以及我们如何解决它们。

### None-code type

非代码字节（如跳转表数据，静态只读数据和填充字节）通常出现在代码段中。 libc 2.12的代码示例如图1所示，其中跳转表位于代码段中。 如果跳转表被误解为代码，我们可能会错误地将其内容标识为有效指令，如灰色阴影单元格所示。

一些现有的工具包使用线性扫描来发现代码[3,20,22]。 该方法从特定点开始顺序解码指令，例如程序入口点或已知的功能入口点。 在图1中，在地址80b15ee处的间接跳转被解码之后，使用线性扫描方法的工具包将继续解码跳转表中的非代码字节。 如果这些非代码字节对应于有效指令，则很难知道停止扫描。

### Missing Symbols

剥离的“二进制文件”的符号表已被删除。函数符号是关于函数入口点的主要数据源，它是准确和完整的代码发现以及确定函数边界的基础。

检测剥离二进制文件中的函数入口点的一种方法是基于以下观察：函数通常在条目处具有共同操作，例如设置堆栈帧。 这些常见操作导致共同的指令序列。 如果我们可以学习这些序列，我们可以找到函数入口点。 上述观察导致基于模式匹配的方法，其使用少量手动设计的指令模式[21,22,25,35,47]。 然而，这种方法已被证明是不充分的，因为它无法适应编译器和优化级别的变化[5,43]。

最近的工作使用有监督的机器学习技术来学习识别功能入口点的功能[5,43]。 Dyninst使用Rosenblum等人的方法[43]来识别函数入口点。 他们的方法从训练二进制集中提取指令序列，并为每个指令序列分配权重，以表示当地址处的指令序列匹配时地址是函数入口点的概率。 我们应用Rosenblum等人的方法[43]来训练基于Bao等人发布的二进制代码数据集的新模型。 [5]并得到类似的切入点识别结果。

### Overlapping Instructions

重复说明通常出现在恶意软件中。 图2显示了这样一个例子，其中三个块序列重叠，并且所有三个序列将在恶意软件中的某个点执行。 但是，我们也在传统代码中观察到了这种代码构造。 如图3所示，这个代码示例中的两条指令与libc-2.12.so重叠。 当程序是多线程时，程序执行序列1.当程序是单线程时，执行序列2中的指令; 在这种情况下，省略了锁定pre x以避免锁定开销。

SecondWrite [47]将跳转到指令的中间作为无效情况，因此它无法处理重叠指令。 Dyninst删除约束并遵循控制流转移以报告重叠指令

## CFG Construction

间接控制流和非返回功能使CFG的构造复杂化。 对于间接控制流程，我们专注于精确解析跳转表。 以前的工具使用以下三种方法之一来处理跳转表：

（1）深度分析可以分析所有间接控制流[4,6,28,29]，（2）编译器特定模式以识别跳转表[21,26]，或（3）基于原理的跳转表分析 跳转表的有限定义[13]。 第一种方法可以处理所有类型的跳转表，但在许多情况下会报告跳转表的不精确控制流目标。 第二种和第三种方法可以精确地解决某些特定类型的跳转表，但无法解决现代编译器引入的新类型的跳转表。

### Jump Tables

我们对跳转表的处理基于新的跳转表模型和实现该模型的数据流分析。 我们首先介绍跳转表的建模。 我们的模型将跳转表计算抽象为计算跳转目标的单变量函数，我们称之为跳转表目标函数。 跳转表目标函数有几个跳转表参数，包括表的内容，位置和大小。 要静态解析跳转表，必须分析代码以确定跳转表目标函数的形式并提取跳转表参数的值。 我们提供三个跳转表示例来解释如何实现我们的模型。 最后，我们讨论我们的分析，这些分析改进了我们填充模型和解决跳转表的能力。

跳转表主要在四个维度上变化：表内容是跳转目标地址还是相对于基地址的跳转目标偏移，表的位置是在指令中显式编码还是计算，跳转表的输入是否有界 通过条件跳转或计算限制，以及地址计算中涉及的表的级别数。 我们的跳转表模型分为以下几个部分来捕捉这些变化。 首先，我们定义了一级跳转表函数JT，它从一级表中抽象读取值。 接下来，我们定义t级跳转表函数JTt，它抽象出如何组合多个一级跳转表函数以形成一个t级表。 最后，我们定义跳转表目标函数JTT，它使用JTt返回的值计算控制流目标。

### None-returning Functions

无法识别非返回功能会引入虚假控制流边缘。以前的工具要么假设所有函数都返回到它们的调用站点[29]，要么使用简单的名称匹配方法来识别非返回函数[5,21]。此名称匹配方法检查函数调用的被调用者是否在众所周知的非返回函数列表中，包括退出和中止。如果被调用者在列表中，则函数调用将永远不会返回。这样的列表通常仅包括众所周知的库中的非返回函数，例如libc。这种名称匹配方法通常可以有效地应用于剥离的二进制文件。关键是确定函数调用是否针对已知的非返回函数。对于动态链接的剥离二进制文件，保留导入函数的符号以支持链接，以便调用动态链接库中的目标名称;对于静态链接的剥离二进制文件，库ngerprinting可用于标识正在调用的库函数

鲍等人。 [5]描述了对这种名称匹配方法的改进，注意到如果函数f总是调用函数g，并且g被标识为非返回函数，则f也应该被认为是非返回函数。

图7显示了由GCC 4.4.7编译的GCC 4.9.2本身的示例，其中Bao等人的技术无法识别两个相互递归的非返回函数。在此示例中，fancy_abort和internal_error是两个相互递归的函数。一旦程序进入fancy_abort或internal_error，程序可能会到达退出或由于堆栈溢出而发生错误。在任何一种情况下，fancy_abort和internal_error都不会返回其调用者，因此它们是非返回函数。在将Bao et al。的技术应用于此示例时，我们首先注意到internal_error和fancy_abort都不是已知的非返回函数。然后我们发现internal_error总是调用fancy_abort，但是我们不能断定innnnal_error是一个非返回函数而不知道fancy_abort是不返回的。同样，我们不能断定fancy_abort是一个非返回函数，而不知道internal_error是不返回的。因此，该技术将失败，因为两个非返回函数形成循环依赖性。

我们设计了一个过程间分析来确定程序中的所有非返回函数，如图8所示。我们使用x点计算来检测循环依赖性。 请注意，一旦程序进入循环依赖项中的任何函数，程序就可以到达已识别的非返回函数，或者在堆栈飞过之前保持循环。 因此，所有涉及的功能都可以标记为不返回。 我们的分析将程序中的函数集F和一组已知的非退回函数NonRet作为输入; 分析输出一组已识别的非返回函数nonRet。 我们计算每个函数的返回状态。 返回状态可以是\ unknown，“\可能返回”或\不返回。“设置nonRet和ret代表当前标识的\不返回”和\可能返回“函数，最初，所有函数都有\ 未知的“返回状态。

在我们的分析开始时，knownNon-Ret中的所有函数都设置为\不返回“（第1行）。然后我们执行ax点计算以确定F中所有其他函数的返回状态（第5-13行） 在我们达到斧点之后，可能在返回状态保持为“未知”的函数之间存在循环依赖性。 我们将所有这些设置为“不返回”

### Complex Functions

### Tail calls

尾部调用用跳转替换调用指令以消除堆栈帧设置和拆除。 识别尾调用的简单策略是将针对函数符号的跳转视为尾调用。 但是，当编译器不生成预期符号时，即使对于非剥离二进制文件，此策略也不起作用。 图10显示了RedHat 6 Linux上libbz2.so.1.0.4的一个示例，其中BZ2_bzdopen和BZ2_bzopen对bzopen_or_bzdopen执行尾调用。 编译器没有为bzopen_or_bzdopen生成符号。 因此，工具包必须依赖启发式来合理地解析代码，或者将bzopen_or_bzdopen标记为由其他两个函数共享的代码，或者更优选地，作为尾部调用的函数。 在这种情况下，源代码和二进制代码之间可能存在多个一致且合理的语义映射。