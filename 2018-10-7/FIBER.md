## Precise and Accurate Patch Presence Test for Binaries

### Abstract

补丁是解决软件漏洞的主要手段。 确保补丁及时传播到所有受影响的软件至关重要，但遗憾的是，情况往往并非如此。 因此，对于防御者和攻击者来说，准确测试软件分发中的安全补丁存在的能力是至关重要的。

受人类分析师仅检查小型和本地化代码区域的行为的启发，我们提出了一种自动化系统FIBER，该系统在其核心设计中利用了这一观察结果。 FIBER首先仔细解析和分析开源安全补丁，然后生成细粒度的二进制签名，忠实地反映补丁引入的最具代表性的语法和语义变化，用于搜索目标二进制文件。 与之前的工作相比，FIBER通过主要关注补丁和最小上下文的小变化而不是整个功能或文件来战略性地利用源级别的洞察力。 我们使用来自3个不同主流供应商的107个真实安全补丁和8个Android内核映像系统地评估了FIBER，结果表明FIBER可以达到94％的平均准确度，没有误报。

### Introduction

近年来，新发现的安全漏洞数量迅速增加[3]，对各种软件和最终用户构成严重威胁。 用于对抗漏洞的主要方法是修补; 然而，确保安全补丁及时传播到大量受影响的软件分发是一项挑战，特别是对于具有多个并发开发分支（即上游与下游）的大型项目。 这是由于现代软件工程实践中重复使用代码[16,23,20]。因此，对于防御者和攻击者来说，测试某个安全补丁是否应用于软件分发的能力是至关重要的。

为了更好地促进论文的讨论，我们将补丁存在测试的目标和范围与更一般的错误搜索区分开来。 补丁存在测试，顾名思义，检查特定补丁是否已应用于未知目标，假设知道受影响的功能和补丁本身，例如“openssl库的漏洞是否已经修补了tls1进程中的heartbeat（）函数“。 另一方面，错误搜索不会假设哪些目标函数受到影响，只是查找与易受攻击的函数类似的所有函数或代码片段，例如，“软件分发中的哪些函数看起来像 一个易受攻击的版本的tls1进程heartbeat（）。“我们的研究侧重于更具体的补丁存在测试问题，旨在提供精确和准确的答案。 考虑到这一点，在以下背景下研究了两个方面的工作：

**Source to Source**。这种类型的工作纯粹在源代码级别上运行。 参考和目标都需要源代码。 在最近的研究中，通常还假设有关于特定错误的补丁可用。

**Binary to Binary**。这些工作不需要任何源代码。 引用和目标都是二进制的，因此所有比较仅基于二进制级功能。 它不假设补丁信息的可用性（关于哪个二进制指令与补丁相关）。

在本文中，我们考虑一个新的“源到二进制”类别，它是上述两者之间的中间点，基于以下观察。 首先，开源已成为当今计算机世界的一种趋势，其中开源的软件数量激增，提交和补丁的完整历史记录（例如，托管在github上）[4]。 事实上，大多数仅二进制错误搜索研究包括Linux和openssl等软件。 其次，许多开源代码或组件在封闭源软件中被广泛重用，例如，IoT固件中的库和基于Linux的内核[13,26]。 这是一个重要的变化，它允许我们利用可以通知二进制补丁存在测试的源级别洞察力。

不幸的是，关于仅二进制错误搜索的密切相关的工作错过了一个重要的链接，以便被扭曲以执行准确的补丁存在测试。 由于其范围极大，他们被迫使用基于相似性的模糊匹配（本质上不准确）来加速搜索过程，而不是更昂贵但更准确的方法。 因此，大多数现有解决方案通常将整个功能用于比较[26,27,13,31]。 但是，由于安全补丁大多是小而微妙的变化[30]，基于相似性的方法无法有效区分修补版本和未修补版本。

在本文中，我们提出了FIBER，一个完成缺失链接的补充系统，并将基于相似性的错误搜索提升到下一个级别，我们可以在其中执行精确和准确的补丁存在测试。 从根本上说，FIBER解决了以下技术问题：“我们如何生成能够很好地代表源代码补丁的二进制签名”？ 我们分两步解决这个问题：首先，受典型人类分析师行为的启发，我们将挑选最合适的补丁部分作为二进制签名生成的候选者。 其次，我们生成二进制签名，尽可能多地保留源级信息，包括补丁和整个相应的函数。

contributions:

* 我们在“源到二进制”下制定了补丁存在测试的问题，弥合了从一般错误搜索到精确和准确的补丁存在测试的差距。 然后我们描述了FIBER--一种自动，精确，准确的系统，可以克服二进制文件中信息丢失等挑战。 FIBER是开源的。
* 我们设计了受人类行为启发的FIBER，它挑选并选择补丁中最合适的部分来生成代表源级补丁的二进制签名。 此外，测试结果也可以由人类轻易推理。
* 我们系统地评估了具有107个真实字漏洞和安全补丁的FIBER，这些漏洞和安全补丁位于具有不同时间戳，版本和供应商的各种Android内核映像2上，结果显示FIBER可以进行安全补丁存在测试。 我们发现了关键安全补丁无法传播到下游的真实案例。

### Related Work

在本节中，我们将讨论主要在错误搜索下的相关工作，以及它们当前如何应用于补丁存在测试问题。 我们将它们划分为source-level和binary-level。

**Source Level Bug Search**。许多研究都集中在单个软件分发中和分布中寻找代码克隆[18,22,17,16,20]。 总的目标是找到类似于给定的错误的代码片段 - 一个更加通用的目标，可以扭曲以进行补丁存在测试。 由于错误搜索通常不会将搜索范围限制为仅限一个函数，因此需要在大型软件中面对数百万行代码[16]。 由于可扩展性问题，错误搜索解决方案通常被构造为使用从源代码中提取的特征的某种形式的相似性匹配，包括普通字符串[8]，令牌[18,22,16,20]和解析树[17]。 不幸的是，这使得确定所识别的类似代码片段是否已被修补变得具有挑战性; 这是因为修补和未修补的版本可能类似（特别是对于通常很小的安全补丁）

**Binary Level  Bug Search**。与源级工作类似，二进制级方法遵循类似的原理来查找类似的代码片段。为了克服缺少源级信息（例如，变量类型和名称）的挑战，这些解决方案需要寻找替代特征，例如代码结构[19,13,31]。由于“二进制到二进制”错误搜索不假设符号表的可用性，因此即使它只打算对特定函数进行准确的补丁存在测试，它们也必须检查目标中的每个单个函数。例如，给定易受攻击的函数，Genius [13]和Gemini [31]基本上在目标二进制文件的完整函数集合中寻找相同的受影响函数。由于可扩展性再次受到关注，这些功能和解决方案的设计速度而非准确性。 BinDiff [2]和BinSlayer [9]基于同构检查控制流图的相似性。作为更先进的解决方案，Genius [13]和Gemini [31]提取控制流图中的特征表示，并将它们编码为图形嵌入（高维数值向量），这可以加速匹配过程显着。不幸的是，在巨大的搜索空间下，更准确的基于语义的解决方案不被认为是可扩展的[13,31]。例如，Pewny等人。 [26]计算I / O对基本块以匹配目标函数中的类似基本块。 BinHunt [14]和iBinHunt [24]使用符号执行和定理证明来正式验证基本块级语义等价。

FIBER处于一个独特的位置，利用源级信息来回答更具体的问题 - 特定的受影响函数是否在目标二进制文件中进行了修补。 据我们所知，Pewny等人的工作[26]是唯一一个声称可以利用源级补丁信息来生成更细粒度的漏洞搜索签名（尽管没有实现和评估）。 然而，它的目标仍然集中在错误搜索而不是补丁存在测试，这意味着它仍然试图在整个目标中搜索类似的（未修补的）代码片段（二进制），使其过于模糊，无法回答问题 补丁存在测试。

### Overview

在本节中，我们首先通过一个激励性的例子来总结FIBER的一般直觉，然后将FIBER放在更大的图片中。

#### System Architecture

图2说明了系统架构，它是从人类分析师的程序中抽象出来的。它有四个主要输入：（1）源级补丁信息; （2）参考文献的完整源代码; （3）编译参考二进制文件中受影响的函数; （4）目标二进制文件中受影响的函数。很明显，如果符号表包含在目标二进制文件中（例如，在大多数基于Linux的内核映像中为真），则（4）很容易获得。然而，在更一般的情况下，我们没有做出这个假设，最先进的二进制错误搜索工作也没有[13,31,26]。幸运的是，这些基于相似性的方法通过识别目标二进制中看起来类似于参考的函数来解决这个问题，因此除了研究[13,31]之外，实际上可以推断出目标二进制的符号表[13,31]， BinDiff [2]还具有用于此目的的内置功能。我们将此类功能集成到FIBER中作为未来工作，因为在我们的评估中作为测试主题的所有内核映像都嵌入了符号表。

这表明基于相似性的错误搜索和更精确的补丁存在测试实际上不是竞争解决方案; 相反，它们相互补充。 前者快速/可扩展但不太准确; 后者较慢但更准确。 在某种程度上，错误搜索充当粗粒度过滤器并输出候选函数的排序列表，其可以用作FIBER的输入（4）以供进一步处理。 由于FIBER的搜索空间现在仅限于少数候选函数（如果使用符号表，则为一个），这会打开更昂贵的分析。

考虑到输入，我们现在描述FIBER中的三个主要组件：

* Change site analyzer。单个补丁可能会在不同的功能中引入多个更改站点，而一个更改站点也可以跨越源代码中的多个行。 变更站点分析器打算通过仔细分析每个变更站点和相应的参考函数来挑选那些最具代表性，独特且易于匹配的源变更，模仿真正的分析师会做什么。 此外，在此过程中，我们还可以获得有关变更站点（例如，语句类型和所涉及的变量）的有用的源级洞察，这可以指导后面的签名生成和匹配过程。
* Signature generator。该组件负责将源级别更改站点转换为二进制级别签名。 本质上，此步骤需要进行分析，以确保我们可以将二进制指令映射到源级语句，由于编译过程中的信息丢失，这很有挑战性。 我们利用的关键构建块是用于此目的的二进制符号执行。
* Matching engine。匹配引擎的任务是搜索目标二进制文件中的给定签名。 为此，我们首先需要在符号表的帮助下在目标二进制文件中找到受影响的函数。 然后通过首先匹配由与补丁相关的本地化CFG的拓扑表示的语法（更快的过程），然后是语义公式（由于符号执行而更慢）来完成搜索。 该过程类似于激励示例中描述的过程。

值得注意的是，只要为特定安全补丁生成签名，就可以将其保存并重用于多个目标二进制文件，因此我们只需要为每个补丁运行一次分析器和生成器。

#### Scope

1. FIBER自然支持分析不同架构的二进制文件，并使用不同的编译器选项进行编译。 这是因为源代码的可用性允许我们使用任何编译器选项将源代码编译到任何支持的体系结构中。 更多细节将在§5和§6中讨论。
2. FIBER本质上不依赖于任何源语言，尽管它目前适用于C代码。 我们确实要求编译器生成调试信息（对于我们的参考二进制文件），编译器可以将二进制指令映射回源级语句，这将在§4.3中讨论。 例如，所有现代C编译器都可以这样做。

#### Potential users and usage scenarios

我们设想第三方审核员/开发人员将成为FIBER的主要用户，例如独立安全研究人员，安全公司，依赖其他人提供的代码/二进制文件的软件集成公司。 即使对于第一方开发人员，在二进制级别检查安全补丁也提供了额外的安全层。 正如§6.4所示，一些供应商确实忘记修补关键漏洞，即使他们有源访问权（即人为错误），而像FIBER这样的系统可能已经抓住了它。

### System Design

#### Signature

签名代表补丁。 一般来说，我们有两个“理想”签名标准：

1. Unique。签名不应该在补丁本身以外的地方找到。 否则，它不是补丁独有的。 具体来说，它不应该存在于已修补和未修补的版本中。 这意味着签名不应过于简单，这可能导致签名出现在与补丁无关的位置。
2. Stable。签名对于代码库的良性演化应该是鲁棒的，例如，由于版本差异，目标函数可能看起来不同于作为参考。 这意味着签名不应过于复杂（与太多源代码行相关），这更有可能在目标中遇到良性变化，从而导致签名的错误匹配

正如我们所看到的，上述两个看似矛盾的要求要求签名生成之间的微妙平衡，我们将在本节中详细说明。 从根本上说，我们需要从补丁中选择一个独特的源更改，我们相信可以生成一个很好地代表它的相应二进制签名。 对我们有利的是，引用和目标函数应该共享重要的变量级语义。 假设两个版本都已修补，“变量如何导出和解除引用”以及“如何导出条件”等内容应该非常相似。 二进制签名只需要携带这些必要的信息来恢复源中存在的语义。

非正式地，我们将二进制签名定义为一组指令，不仅在结构上对应于源级别签名，而且还注释了足够的信息（例如，变量级别语义），以便它们可以明确地映射到原始源级别更改站点。 我们将在§4.3中详细说明翻译过程。

#### Change Site Analyzer

变更站点分析器的输入是源补丁和参考代码库。 它有两个目的。 （1）由于补丁可能在不同功能内或跨越不同功能引入多个变更站点，因此分析仪的目的是根据§4.1中提到的标准选择合适的签名。 （2）另一个目标是获得补丁更改站点的见解，二进制签名生成器将从中受益。 我们将这个过程分为两个阶段，详细说明如下。

##### Unique Source Change Discovery

补丁可以添加或删除一些行，因此我们可以基于补丁的缺失（即，删除的行的存在）或补丁的存在（即，存在添加的行）来改变。 出于讨论的目的，我们假设我们的签名生成基于补丁的存在并且专注于增加的线; 相反的情况可以类似地完成。 总体战略是从单一陈述开始，并在必要时逐步扩大。 对于修补程序中的每个添加的语句，将执行以下步骤：

1. Uniqueness test。基本上，语句必须仅存在于补丁的添加行中，而不存在于其他任何地方（例如，未修补的代码库）。 为此，我们可以使用词法分析器[16]应用基于令牌的简单序列匹配。 我们希望指出，这种唯一性测试不仅捕获基于令牌的信息，还捕获语义相关信息。 例如，图1中第11行的示例源签名编码第一个函数参数与最后一个参数的字段进行比较的事实，并且这种语义关系是唯一的（我们需要在二进制签名中保留）。
2. Context addition。如果没有单个语句是唯一的，我们将其所有相邻语句视为潜在的上下文选择。 “相邻”是双向的并且在控制流级别上（例如，“if”语句具有两个后继，并且两者都可以被认为是上下文），因此可以存在多个上下文语句。 我们逐渐扩展上下文语句，例如，如果一个上下文语句不够，我们尝试两个。
3. Fine-grained change detection。按照惯例，补丁以源代码行更改的形式分发。 即使部分修改了一条线，相应的补丁仍会显示一条已删除的线和一条添加的线。 我们通过将其与其相邻的已删除/添加的行进行比较，在单个语句/源行中检测到这种细粒度的更改。 这是为了确保我们不包含会使签名膨胀的不必要的声明部分。 例如，如果只更改了函数调用语句的一个参数，我们可以忽略匹配过程中的所有其他参数，以减少潜在的噪声，从而提高签名的“稳定性”。
4. Type insight。源语句中涉及的变量类型也很重要，因为它将指导后面的二进制签名生成和匹配。理论上，我们可以标记引用二进制文件中每个变量的类型（二进制文件中的寄存器或内存位置），并确保目标中推断的类型匹配（更多细节见§4.3.1）。但是，有时类型匹配不足以唯一匹配签名。一种特殊情况是const字符串，它静态存储在硬编码的内存地址中。如果补丁中的唯一更改与字符串的内容相关，则二进制签名生成和匹配都应取消引用char *指针并获取实际的字符串内容;否则，签名将只包含一个const内存指针，其值可以在不同的二进制文件中变化。即使指针类型在目标中匹配为char *，如果它是修补或未修补的版本，它仍然是不确定的（我们在§6中给出了一些实例作为案例研究）。

##### Source Change Selection

上一步可以为单个补丁生成多个候选唯一源更改。 实际上，其中一个的存在可能已经表明补丁存在。 此外，一些源更改比其他源更改更适合二进制签名生成。 在FIBER中，我们将首先对所有候选更改进行排名，然后选择前N个进一步翻译。 排名基于三个因素（从最不重要到最重要）：

1. Distance to function entrance。源级签名中的语句与函数入口之间的短距离将加速签名生成过程，因为其设计将在§4.3中详细说明。

2. Function size。如果源代码签名位于较小的函数中，则匹配引擎将受益，因为搜索空间将减少并且不太可能遇到“噪声”。 此外，匹配速度会更快。 注意，这比（1）更重要，因为签名生成过程只是一次性的努力，而匹配可以针对不同的目标二进制文件重复。

3. Change type。变更涉及的陈述类型很重要。 如前面§3所示，如果更改涉及某些结构/控制流更改（例如，“if”语句），我们可以快速将搜索范围缩小到目标二进制文件中结构相似的候选项，从而影响匹配速度。 更重要的是，它还会影响二进制签名的稳定性。 与函数调用之类的语句不同，函数调用可能会根据编译器选项进行内联，因此结构更改通常更加健壮。 

   我们将源更改分为几种常规类型：（1）函数调用（新函数调用或参数更改为现有调用），（2）条件相关（新条件语句或现有语句中的条件更改），（3）赋值（可能涉及算术运算）。实际的源更改可以有多种类型，例如，函数调用可以具有从赋值派生的参数或遵循条件语句。通常，我们将“新函数调用”（如果FIBER确定它没有在参考binary5中内联）排名最高，因为可以通过函数调用的存在简单地确定补丁存在，这对于符号表是直截了当的。我们还将“条件”相关签名（例如，“if”语句）排在高位，因为它引入了结构变化和语义变化。另一方面，简单的赋值语句，包括从算术运算导出的赋值（例如，a = b + c;），一般不会影响结构，因此不太优选。此外，纯粹的控制流转移（例如，添加“goto”）也不是优选的，因为我们可能需要包括与更改站点无关的额外上下文语句，这些语句不太稳定。请注意，有某些来源 - 级别更改在二进制级别（例如，源代码注释）或难以定位（变量声明）中根本不可见。



