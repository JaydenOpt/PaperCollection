# BinMatch

### Abstract

二进制代码克隆分析是一种重要的技术，在软件工程中具有广泛的应用（例如，抄袭检测，错误检测）。 该主题的主要挑战在于语义等价的代码转换（例如，优化，混淆）将极大地改变二进制代码的表示。 另一个挑战是检测准确度和覆盖率之间的权衡。 不幸的是，现有技术仍然依赖于语义易受代码转换影响的代码功能。 此外，它们仅采用静态或动态方法来检测二进制代码克隆，这不能同时实现高精度和覆盖。

在本文中，我们提出了一种基于语义的混合方法来检测二进制克隆函数。我们使用其测试用例执行模板二进制函数，并模拟每个目标函数的执行，以便与从该模板函数迁移的运行时信息进行克隆比较。在执行模板功能和模拟目标功能期间提取语义签名。最后，根据他们的签名计算相似度得分以测量他们的相似度。我们在指为BINMATCH的原型系统中实现该方法，该系统在Linux平台上分析IA-32二进制代码。我们使用不同的编译配置和常用的混淆方法编译了八个真实项目来评估BINMATCH，完全执行超过1亿对功能比较。实验结果表明，BINMATCH对语义等价的代码转换具有鲁棒性。此外，它不仅涵盖了克隆分析的所有目标功能，而且与最先进的解决方案相比，还提高了检测精度。

### Introduction

二进制代码克隆分析是软件工程中的基础技术。 它在软件维护和安全领域有重要应用，例如抄袭检测[20]，[45]，补丁代码分析[5]，代码搜索[6]，程序理解[18]，恶意软件谱系推理[32] ，[30]，[1]，已知漏洞检测[34]，[12]，[13]等。

影响二进制代码克隆分析准确性的主要挑战源于语义等效代码转换（C1），通常包括编译器的链接时优化和代码混淆[11]。转换修改二进制代码的表示。尽管从相同的代码库编译了两段代码，但是在转换之后得到的二进制文件在语法或结构级别（例如，指令，控制流程图）上显着不同。另一个挑战是检测准确度和覆盖率（C2）之间的权衡，这对应于分析动态或静态方式的二进制代码[39]。动态方法从代码执行中获取丰富的语义以确保高精度，但它们仅分析执行的代码，从而导致低覆盖率。相比之下，静态方法能够覆盖所有程序组件，而它们更多地依赖于缺乏语义的语法和结构特征。另外，静态方法不能决定间接跳转和调用的目标。因此，静态方法的分析准确性相对较低。

在本文中，我们提出了一种基于语义的混合方法BINMATCH来检测二进制克隆函数。给定模板函数，BINMATCH首先检测并用测试用例执行它以记录其运行时信息（例如，函数参数值）。然后，它将信息迁移到每个候选目标函数并模拟函数的执行。在执行和仿真期间，记录模板和目标函数的语义签名。最后，BINMATCH比较模板函数和每个目标函数的签名以测量它们的相似性。为了克服语义等价代码转换的C1，BINMATCH仅依赖于从整个模板或目标函数中提取的语义签名。为了解决C2在准确性和覆盖范围之间的权衡，BINMATCH采用混合方法，以静态和动态方式捕获语义签名。通过执行模板功能，BINMATCH捕获其丰富语义的签名。然后，它使用模板函数的运行时信息模拟每个候选目标函数以提取其签名，这考虑了所有目标函数。

BINMATCH通过使用各种编译配置和混淆设置编译的八个真实项目进行评估，完全执行超过1亿对功能比较。 实验结果表明，BINMATCH不仅对语义等效的代码转换具有鲁棒性，而且优于最先进的解决方案。

总之，本文的贡献如下：

* 我们提出了一种基于语义的混合方法来分析二进制代码克隆。 该方法以动态（执行）或静态（仿真）方式捕获二进制函数的语义签名。 因此，它不仅可以使用丰富的语义签名准确地检测克隆功能，而且还可以覆盖所有正在分析的目标函数。
* 为了平滑运行时信息的迁移和函数的仿真，我们提出了处理全局变量读取，间接调用/跳转和库函数调用的新策略。
* 我们在原型系统BINMATCH中实现该方法，该系统支持Linux平台上的IA-32二进制代码克隆分析。 BINMATCH使用八个实际项目进行评估，这些项目使用不同的编译配置和混淆设置进行编译。 实验结果表明，BINMATCH对语义等价的代码转换具有鲁棒性。 此外，它涵盖了克隆分析的所有候选目标函数，并且从==准确性== 的角度来看优于最先进的解决方案。

### Motivation and Overview

在本节中，我们首先提供一个示例来说明以前的二进制代码克隆分析工作的局限性，这推动了我们的研究。 然后，我们解释了我们方法的基本思想并展示了系统概述。

#### Motivation Examples

这是二进制代码克隆检测的典型应用，用于在二进制程序中定位已知易受攻击的代码[34]，[12]，[13]。 给定一段包含已知错误的代码，可以在其他程序中找到相应的克隆（或类似）代码，以检查这些程序是否也易受攻击。

NConvert [42]是一种支持多种格式的闭源图像处理器。它静态链接开源库libpng [29]来处理PNG格式的文件。发现libpng的函数png_set_unknown_chunks在1.5.14版本（CVE-2013-7353）之前包含整数溢出漏洞。有必要在NConvert中找到静态链接的函数，以验证函数是否易受攻击并确保程序安全。由于libpng的源代码可用，因此使用克隆代码检测技术实现目标是合理的。但是，只有NConvert的可执行文件可以访问，其编译配置未知。即使可执行文件是从相同的代码库编译的，也是不同的编译配置将导致语义等效转换（C1），生成具有相同语义的语法和结构变体二进制代码。因此，依赖于语法或结构特征（例如，控制流图同构）的方法变得无效。此外，不仅要准确定位png_set_unknown_chunks，还要实现NConvert（C2）的高代码覆盖率，这具有挑战性。目标函数是静态链接的，与用户定义的混合NConvert的功能。二进制代码克隆检测的静态方法可以覆盖NConvert中的所有函数以查找png_set_unknown_chunks。但是，它们利用无语义功能，产生不准确的结果。相反，动态方法依赖于通过代码执行提取的语义特征，而它们仅关注执行的代码。它甚至需要大量额外的动态工作生成测试用例以覆盖目标函数的方法。不幸的是，代码覆盖仍然是动态分析二进制文件的问题[24]。

#### System Overview of BinMatch

我们建议BINMATCH执行二元函数克隆分析。 给定二进制函数（模板），BINMATCH在目标二进制程序中找到其克隆匹配，从程序返回一个函数列表（目标），该列表基于语义相似性进行排序。

图1显示了BINMATCH的工作流程。 鉴于已经很好地分析或理解的模板函数（png_set_unknown_chunks），BINMATCH会使用测试用例并执行它，捕获其语义签名（§III-A）。 同时，在执行期间也记录运行时信息（§III-B）。 然后，BINMATCH将运行时信息迁移到目标二进制程序（NConvert）的每个目标函数。 它模拟目标函数的执行以提取语义签名（§III-C）。 之后，BINMATCH将模板函数的签名与每个目标函数的签名进行比较，并计算它们的相似性得分（§III-D）。 最后，生成目标函数列表，其按相似度分数按降序排列。

总之，为了克服C1，BINMATCH完全依赖于语义签名来检测二进制函数克隆。 另外，签名以混合方式捕获，其解决C2。 BINMATCH首先通过执行其测试用例来提取模板函数的签名。我们假设模板函数已被充分研究，其测试用例可用。 在上面的示例中，已知png_set_unknown_chunks的漏洞，其测试用例可以在libpng项目中找到，也可以在漏洞数据库中找到。 然后，利用模板函数的运行时信息，BINMATCH通过仿真生成正在分析的二进制程序（NConvert）的每个目标函数的签名。 因此，BINMATCH能够覆盖所有目标函数，以检测其克隆匹配与丰富语义的签名。

### Methodology

在本节中，我们首先介绍BINMATCH采用的语义签名，然后讨论它如何捕获二进制函数的签名并测量它们的相似性。

#### Semantic Signatures

对于每个二进制函数，BINMATCH在执行或仿真期间捕获行为作为其签名。 给定特定输入，签名指示函数如何处理输入并生成输出，反映该函数的语义。 签名包含以下特征：

* Read and Written Values：该特征包括在（仿真）执行期间从存储器读取或写入的全局（或静态）变量值。 它包含函数的输入和输出值，当提供特定输入时，指示函数的语义。
* Comparison Operand Values：该特征由比较操作的值组成，其结果决定（仿真）执行的以下控制流。 它指示函数的路径，后跟输入以生成输出。 因此，它也是语义相关的。
* Invoked Standard Library Functions：标准库函数提供了实现用户定义函数的基本操作（例如，malloc，memcpy）。 该特征已被证明与语义相关且对代码克隆分析有效[41]，[40]。 因此，它被用作BINMATCH的语义签名的补充。

在执行或仿真期间，BINMATCH捕获上述特征的序列，并将序列视为二进制函数的签名，用于后面的相似性比较。

#### Instrumentation and Execution

在此步骤中，BINMATCH通过运行测试用例来检测二进制函数F以生成其签名。 同时，还记录了仿真的运行时信息（“III-C”）。

算法1呈现了伪代码检测。 BINMATCH遍历F的每个指令（I）。如果我访问全局变量，执行比较操作或调用标准库函数，BINMATCH在I之前注入代码以捕获相应的特征并生成F的签名（第4-9行）。

第11-16行显示了用于记录F执行的运行时值的代码。 根据cdecl，IA-32二进制文件的默认调用约定，函数参数由调用者准备并通过堆栈传递。 因此，如果我在调用F之前读取一个被压入堆栈的变量，BINMATCH会将该变量视为函数参数并记录其值（第11-12行）。 此外，BINMATCH间接记录由F调用的子程序的地址（第13-14行）。 还记录所有子程序的返回值，包括用户定义的函数和标准库函数（第15-16行）。

#### Emulation

对于要与模板函数F进行比较的每个目标函数T，BINMATCH使用从最后一步提取的运行时信息模拟其执行。 同时捕获T的语义签名。 如果使用相同的输入执行克隆函数，它们的行为应该类似[11]。 即，如果T是F的克隆匹配，则它们的签名应该是相似的。 算法2给出了仿真的伪代码。 BINMATCH为T提供F（第2行）的参数，并使用F（第20行）的运行时信息对其进行仿真。 此外，BINMATCH记录T的特征以生成其签名（第18-19行）。 接下来，我们将更详细地讨论仿真算法。

1. 函数参数赋值：在我们的场景中，用于比较的二进制函数是从相同的代码库编译的，即克隆函数具有相同数量的参数。 根据调用约定，BINMATCH识别目标函数T的参数。如果T的参数号等于F的参数号，则BINMATCH按顺序将F的参数值分配给T的参数值。 否则，BINMATCH会跳过不能匹配F的T仿真。例如，F和T有以下参数列表：

   如果BINMATCH具有farg_0和farg_2的值，F只访问执行中的两个参数，则BINMATCH将它们的值分别分配给targ_0，targ_2。 为了顺利进行仿真，将为没有相应值的参数（targ_1）分配预定义值

2. 全局变量读取：在模板函数F的执行中，它可能读取其值已被先前执行的代码修改的全局（或静态）变量。 为了模拟F的存储空间中的目标函数T，BINMATCH将F的全局变量值迁移到T读取的相应地址。 BINMATCH需要考虑两点：i）获取T读取的全局变量地址（算法2的第5行），以及ii）将相应的全局变量值从F的存储器迁移到T的存储器（算法2的第7行））。

   全局变量存储在二进制程序的特定部分（例如，.data）中。 每个变量的大小由源代码决定。 变量的位置，包括全局数据结构（例如，数组）的基地址，在编译后在二进制代码中确定，之后不再改变。 因此，使用硬编码地址访问全局变量。 通过将其相应的偏移量添加到常量基址来访问全局数据结构的每个成员，并且从输入（函数参数）生成偏移量。 因此，BINMATCH能够在仿真期间轻松获得T的全局变量地址。

   BINMATCH根据其==使用顺序==迁移全局变量值。图2显示了全局变量值迁移的两个函数示例。在执行F期间，在图2a中分别在第1行和第3行读取两个全局变量gvar1和gvar2。 gvar1用于在第2行测试其值，gvar2用于第4行的加法运算。因此，两个变量的使用顺序为[gvar1，gvar2]。当模拟图2b中的T时，BINMATCH识别ecx和ebp在第1行和第2行加载全局变量gvar1'和gvar2'。然后，它发现ebp用于第3行的测试，并且ecx用于在之后是4号线。图2b中全局变量的使用顺序是[gvar2'，gvar1']。因此，BINMATCH将gvar1的值分配给gvar2'，并将gvar2赋值给gvar1'。如果没有足够的全局值来分配（例如，T读取两个全局变量但F只读取一个），BINMATCH提供T的剩余变量和预定义的值

3. 间接调用/跳转：间接调用的目标由运行时的输入决定。 由于目标函数T是在模板函数F的存储空间中模拟的，如果T是F的克隆匹配，则T的间接调用目标应该是在执行F. BINMATCH期间调用的目标，然后迁移F的返回值。 到T的相应间接调用（算法2中的第10-11行）。 否则，仿真下的目标函数不能与F匹配.BINMATCH停止进程并退出（算法2中的第12行）。

   使用包含目标地址的有序列表的跳转表来实现间接跳转（或分支）。 跳转表存储在.rodata（可执行文件的只读数据部分）中。 因此，类似于读取全局数据结构，通过将偏移量添加到跳转表的基地址来访问跳转表条目。 基址是常量值，偏移量是根据输入计算的。

   图3显示了开关结构的间接跳转。 在第2行，索引值使用edx计算，edx是输入相关局部变量的值，并存储在eax中。 如果索引值不高于0x2A（表示默认情况），则根据基本地址为0x808F630（第5行）的跳转表执行间接跳转。 当跳转表的条目被排序，具有相同的输入时，克隆代码将具有相等的偏移并跳转到相同语义的路径。 BINMATCH只是遵循仿真，不需要为间接跳转做额外的工作。

4. 标准库函数调用：如果目标函数T调用请求系统支持的标准库函数（例如，malloc），则BINMATCH跳过其仿真并为其分配由模板函数F调用的相应结果（第15行 - 16）。 例如，F和T按顺序调用以下库函数：

   BINMATCH分别将malloc_0，malloc_1的返回值分配给malloc_0'，malloc_1'，并跳过仿真。 memset是正常模拟的，因为它不需要系统支持。

### Implementation

BINMATCH通过执行捕获模板函数的语义签名（特征序列），并通过仿真捕获目标函数的语义签名（特征序列）。 在该步骤中，它计算模板函数签名的相似性得分和成对的每个目标函数的相似性得分。 我们利用最长公共子序列（LCS）算法[4]来进行相似性测量。 一方面，从（模拟的）函数执行中捕获签名。 签名中每个条目的出现顺序也是一个特征。 另一方面，签名是从优化或混淆的二进制程序中捕获的，它包含序列中的各种或有噪声的条目。 LCS不仅考虑两个序列的元素顺序进行比较，还允许跳过不匹配的元素，这些元素容忍代码优化和混淆。 因此，LCS算法适用于BINMATCH的签名相似性比较。

相似性得分通过Jaccard指数[15]来衡量。 给定两个语义签名Sf和St，Jaccard指数计算如下：

在此步骤之后，BINMATCH生成目标函数列表，该列表按相似度分数按降序排列。

目前，BINMATCH支持ELF（可执行和可链接格式）文件的IA-32二进制函数克隆分析。 接下来，我们将讨论实施的关键方面。

#### Binary Function Boundary Identification

BINMATCH需要地址和长度的二进制函数来执行克隆分析。 鉴于ELF文件，我们利用IDA Pro v6.6 [7]（一种工业强度逆向工程工具）对其进行反汇编，确定每个二元函数的边界。 IDA Pro的插件IDAPython提供了获取函数地址的接口，即函数（开始，结束），它返回开始和结束之间的函数优先地址列表。 因此，我们使用IDAPython开发一个脚本来自动获取二进制文件的函数地址。 尽管由此产生的IDA Pro拆卸并不完美[2]，但对于BINMATCH来说已经足够了。

#### Instrumentation and Emulation

我们使用Valgrind [33]实现了BINMATCH的仪器模块，这是一个动态的仪器框架。 Valgrind将分析中的二进制代码统一到VEX-IR，一个类似RISC的中间表示（IR），并将检测代码注入IR代码。 然后，它将已检测的IR代码转换为二进制文件以供执行。 IR转换统一了二进制代码的操作，并促进了签名提取的过程。 例如，内存读写操作都与Load和Store统一，后者由VEX-IR定义的操作码。 因此，我们只关注IR的具体操作并忽略IA-32的复杂指令集。

仿真步骤是基于angr [36]实现的，这是一个静态二进制分析框架。 angr借用Valgrind的VEX-IR，将要分析的二进制代码翻译成IR静态。 给定用户定义的初始状态，它提供一个名为SimProcedure的模块来模拟IR代码的执行。 SimProcedure允许注入额外的代码来监控IR代码的仿真。 它实际上模仿了仪器的过程。 此外，angr维护着一个标准库函数数据库，以简化这些函数的仿真（“III-C4”）。 因此，我们开发了一个监视代码的脚本，它类似于使用Valgrind开发的检测代码，用于在使用angr进行仿真期间捕获语义签名。

#### Similarity Comparison

由于签名序列的长度可能超过104，因此传统LCS算法（其存储器复杂度为O（mn））的可能性很高，以耗尽存储器。 我们使用Hirschberg算法[17]实现BINMATCH来计算LCS，该算法只需要O（min（m; n））个存储空间。

### Evaluation

我们进行实证实验来评估BINMATCH的有效性和容量。 首先，使用使用不同编译配置编译的二进制文件来评估BINMATCH，包括变体优化选项和编译器。 然后将结果与现有解决方案（§V-B）的结果进行比较。 其次，我们通过比较二进制程序与其混淆版本（§V-C）来评估BINMATCH处理混淆的有效性。 最后，通过§II-A中描述的NConvert的激励示例，我们展示了BINMATCH如何定位NConvert（§V-D）的静态链接缺陷函数。

#### Experiment Setup

The evaluation is performed in the system Ubuntu 16.04 which is running on an Intel Core i5-2320 @ 3GHz CPU with
8G DDR3-RAM.

1. 数据集：我们采用八个真实项目的程序作为评估对象，如表I所列。目标程序具有各种功能，如数据压缩（gzip），代码解析（lua），电子邮件发布（mutt）， 对于这些目标程序，BINMATCH的有效性不受所分析的程序和功能类型的限制。

   在第一组实验（§V-B）中，目标程序用不同的编译器编译，即gcc v4.7和clang v3.8.0，以及变体优化选项，即-O3和-O0。 在第二组实验（§V-C）中，我们采用Obfuscator-LLVM v4.0.1（OLLVM）[22]来混淆对象程序以进行比较。 OLLVM提供了三种广泛使用的混淆技术。 我们利用这三种技术来混淆分别用-O3和-O0优化的目标程序。 因此，我们为每个目标程序编译10（= 2？2 + 3？2）个唯一的二进制可执行文件，总共80（= 10？8）用于评估。

   对于每个实验，我们从对象程序的10个可执行文件中选择两个，即Etem（模板可执行文件）和Etar（目标可执行文件）。 BINMATCH使用从其项目获得的测试用例执行Etem，将每个执行的函数视为模板函数。 然后将每个模板函数与Etar的所有目标函数成对比较，以找到克隆匹配。 平均而言，在执行Etem时会触发291个函数，而Etar包含4,353个函数。 因此，BINMATCH在所有实验中完全执行了超过1亿对功能比较。

2. 基本真相：剥离所有80个可执行文件，以便丢弃其调试和符号信息以进行评估。 为了验证实验结果的正确性，我们编译了80个可执行文件的额外未剥离副本，并用它们的调试和符号信息建立了基本事实。

   对于每个模板函数，BINMATCH生成按相似度得分按降序排列的目标函数列表（如§III-D中所述）。 根据实际情况，如果结果列表中Top 1函数（具有最高相似性得分）的符号名称与模板函数的符号名称相同，则认为该匹配是正确的。 此外，我们手动验证内联函数的情况。 例如，函数A在Etem中调用B，而相应的函数B'在Etar中内联到A'变为A'B'，并且B'消失。 如果BINMATCH将B与A'B'匹配，我们认为它也是正确的。

3. 评估指标：与之前的工作[11]，[18]类似，我们精确地衡量BINMATCH的性能，即找到正确匹配的已执行模板函数的百分比。 公式如下：

#### Accuracy across Compilation Configuration

1. Cross-Optimization Analysis：在本节中，我们利用BINMATCH来匹配不同优化的克隆函数。 对于编译器，更高优化选项包含由较低优先级指定的所有策略。 以gcc为例，选项-O3启用-O2的所有88次优化，并另外打开另外14个优化标志。 因此，我们只讨论-O3（Etem）与-O0（Etar）的情况，它比任何其他交叉优化分析对都有更大的差异。

   图4显示了由gcc（图4a）和clang（图4b）分别编译的每个目标程序的交叉优化分析结果。 在图4a中，BINMATCH为每个目标程序实现了超过82.0％的精度，平均精度为91.5％。 对于图4b中clang编译的每个可执行文件，BINMATCH也正确检测每个对象的80.0％以上的函数，平均精度为92.0％。

   我们观察到函数内联是导致错误匹配的原因。 例如，模板A调用B，而相应的目标函数B'被内联到A'变为A'B'。 因为A'B'的语义特征包含A'和B'的语义特征，所以A的签名长度短于A'B'的签名长度。 因此，函数对（A，A'B'）的相似性得分可能相对较小，而BINMATCH报告错误匹配。

2. Cross-Compiler Analysis：受到编译器浮点数运算的影响，GCC对浮点数的计算有额外操作：判断栈空还是满，Clang没有额外操作。因为这个原因，相同的数在不同的编译器环境下的编译结果不同

3. ComParision with Existing Work：比较了Kam1n0和BinDiff。这两种工具依赖的都是函数的语法和结构特征，在跨平台的比较情况下表现不如BinMatch

4. Processing Time：BinMatch在仿真环节仅仅针对用户定义的函数进行了仿真，对自带函数（内存申请、读写操作）的函数没有进行仿真，节省了大量时间

#### Accuracy of Matching Obfuscated Code

在加入代码混淆（Obfuscated）后比较BinMatch和BinDiff的准确度如何，BinMatch小胜一筹，BinDiff在某些情况下的成绩和BinMatch 相差不多

#### Case Study：libpng vs. NConvert

libpng库有一个漏洞：整数溢出错误，NConvert在函数中调用了这个库，实验进行步骤：

* 运行libpng，并记录函数的语义特征和动态特征
* png_set_unknown_chunks这个函数有四个参数，所以只需要用BinMatch仿真NConvert中的337个参数数量为4的函数。
* 比较签名函数和目标函数，最后耗时57个小时，找到一个函数的最高准确率在37.8%

### Related Works

BinGo：对特征采用用的是随机输入的方式，这样显得输入没有实际意义，并且不能保证触发函数的全部功能

**To Sum Up**，the topic of binary code clone analysis mainly focuses on two points: 

i) what signature to adopt, such as opcodes and operand types (syntax), CFG (structure) and system calls (semantics); ii) how to capture the signatures, such as statically disassembling, dynamically running and sampling